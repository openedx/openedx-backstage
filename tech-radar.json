{
  "title": "Title of your Tech radar",
  "quadrants": [
    {
      "id": "1",
      "name": "Frontend"
    },
    {
      "id": "2",
      "name": "Platform"
    },
    {
      "id": "3",
      "name": "Techniques"
    },
    {
      "id": "4",
      "name": "Tools & Libraries"
    }
  ],
  "rings": [
    {
      "id": "adopt",
      "name": "ADOPT",
      "color": "#93c47d"
    },
    {
      "id": "trial",
      "name": "TRIAL",
      "color": "#93d2c2"
    },
    {
      "id": "assess",
      "name": "ASSESS",
      "color": "#fbdb84"
    },
    {
      "id": "hold",
      "name": "HOLD",
      "color": "#efafa9"
    }
  ],
  "entries": [
    {
      "quadrant": "1",
      "description": "Promise-based HTTP client to make asynchronous HTTP requests to REST endpoints to perform CRUD operations.  This library is used as the basis for the 'auth' module in Blip: frontend-platform and handles all our API communication between micro-frontends and our backend services.  We use its concept of \"interceptors\" to add request and response handling.  Axios is an integral part of our micro-frontend platform today, and we plan to continue to use it.",
      "id": "axios",
      "key": "axios",
      "title": "axios",
      "timeline": [
                {
                    "moved": 0,
                    "ringId": "trial",
                    "date": "2022-02-06",
                    "description": "Long description for trial"
                },
                {
                    "moved": 1,
                    "ringId": "adopt",
                    "date": "2022-02-08",
                    "description": "Long description for adopt"
                }
            ]
    },
    {
      "quadrant": "1",
      "description": "Javascript Transpilation service that allows use of modern JS syntax and tools in older browsers by transpiling advanced ES6 into browser-friendly ECMAScript.  We use this as part of our build process for all modern JS systems.",
      "id": "babel",
      "key": "babel",
      "title": "babel"
    },
    {
      "quadrant": "1",
      "description": "JS UI-creation library present in legacy code systems. It provides a powerful MVC framework, with less focus on small composable code.\nOur legacy JS is written in this architecture, but we are moving away from it as a company, towards React as a framework",
      "id": "backbone",
      "key": "backbone",
      "title": "backbone"
    },
    {
      "quadrant": "1",
      "description": "Powerful industry-standard JS and CSS styling tools, providing sass variables and mixins, a responsive grid system, extensive prebuilt components, and powerful JS plugins.\nThis is the underpinning scaffolding and styling tool library used for much of our Open edX JS/CSS styling.",
      "id": "Bootstrap",
      "key": "Bootstrap",
      "title": "Bootstrap"
    },
    {
      "quadrant": "1",
      "description": "<a href=\"https://www.cypress.io/how-it-works/\">Cypress</a> is an end-to-end testing package with multi-browser support. We have wanted to make use of Cypress for functional testing of our micro-frontends for some time as a means to round out our test suites, which are primarily Blip: Jest based today. See also <a href=\"Playwright.dev\">Playwright.dev</a> and <a href=\"https://github.com/puppeteer/puppeteer\">Puppeteer</a> as alternatives.",
      "id": "cypress",
      "key": "cypress",
      "title": "cypress"
    },
    {
      "quadrant": "1",
      "description": "React component testing library with a particular focus on snapshots and class components.\nWe use this in some MFEs for React unit testing.  Our recommendation is to move away from using enzyme for component testing, and suggest using Blip: testing-library instead.  Enzyme has a more complex set of testing primitives than testing-library, (subjectively) making it a bit harder to reason with. Blip: testing-library has a simpler API, promotes standard ways of querying the DOM, and helps us keep our code accessible by encouraging a11y/ARIA-based querying for writing expectations/assertions.",
      "id": "enzyme",
      "key": "enzyme",
      "title": "enzyme"
    },
    {
      "quadrant": "1",
      "description": "ECMAScript 6 is a version of the ECMAScript standard, providing many advanced syntax and capabilities to modern JS development, including the const/let keywords, class syntax, object destructuring, and more.  All of our modern JS is written in this standard.\n\nOur legacy frontends do not necessarily make use of the syntax improvements and capabilities of ES6, partly because of our outdated build processes in those libraries.  We would like to be able to use modern syntax (supported by Blip: babel) in all our frontends to increase developer velocity and happiness, and improve the readability and quality of our code.",
      "id": "ES6",
      "key": "ES6",
      "title": "ES6"
    },
    {
      "quadrant": "1",
      "description": "es-lint is a linting utility for modern (ES6) Javascript.  Integratable with editors, version control, and build processes.  This is our core/default JS style checker for our modern JS projects and should be our standard across all frontends.  We have a common eslint config in the @edx/eslint-config package.  This config is imported into @edx/frontend-build and made available to all our micro-frontends.",
      "id": "eslint",
      "key": "eslint",
      "title": "eslint"
    },
    {
      "quadrant": "1",
      "description": "Font Awesome is a large and heavily maintained free icon library.  Integrates very easily with React UI development.  This is a legacy icon set that we are transitioning away from, but still serves as the basis of our icon library.  Rather than using font-awesome, we are building an Open edX-specific icon set in Blip: Paragon icons, and encourage our frontends to adopt that instead.",
      "id": "Font Awesome",
      "key": "Font Awesome",
      "title": "Font Awesome"
    },
    {
      "quadrant": "1",
      "description": "We continue to support IE 11 in the near term because edx.org and edX for Business continues to have a number of partners and customers which depend on the browser.  We are actively working with partners to cut over to more modern browsers so we can drop support.  Doing so will allow us to simplify build processes (e.g., transpile less code) and use more modern browser features.  The industry is quickly moving away from IE11, as Microsoft itself has signaled their intention to stop supporting it in Microsoft 365 applications in 2021 and officially dropping support for IE11 in Windows 10 in June 2022.",
      "id": "IE 11 support",
      "key": "IE 11 support",
      "title": "IE 11 support"
    },
    {
      "quadrant": "1",
      "description": "Jest is a JavaScript unit testing framework, providing test structures, assertions, powerful mocking functionality, snapshots, and deep coverage reporting.  This powers all of our unit tests in our micro-frontends.  We use it in conjunction with libraries like Blip: testing-library.",
      "id": "Jest",
      "key": "Jest",
      "title": "Jest"
    },
    {
      "quadrant": "1",
      "description": "JSDoc is a JavaScript documentation tool and standard for writing docstrings for modules, objects, and functions.  Some of our libraries model their documentation structure on JSDoc.  Notably, Blip: frontend-platform generates its documentation site with JSDoc. Investigation hasn't found any other reasonable tools for JavaScript code comments.",
      "id": "JSDoc",
      "key": "JSDoc",
      "title": "JSDoc"
    },
    {
      "quadrant": "1",
      "description": "Lerna is a web-package build tool that optimizes the workflow around maintaining and managing multi-package repositories with git and npm.  We have considered using Lerna in several repositories, such as Paragon.  It has been adopted for a few packages, but is not widely used, as the vast majority of the frontend code is broken up into module/library-specific Git repositories.",
      "id": "Lerna",
      "key": "Lerna",
      "title": "Lerna"
    },
    {
      "quadrant": "1",
      "description": "lodash is a JavaScript utility library providing a wide variety of quality-of-life improvements to working in JS code, particularly utilities for working on strings, objects, and arrays that are available in other languages.  Some of the prominence of this tool has faded as ES6 has brought more power to the base JS syntax.  Our recommendation is to individually install lodash functions in micro-frontends and libraries as necessary, but to avoid installing the entire library at once.  ",
      "id": "lodash",
      "key": "lodash",
      "title": "lodash"
    },
    {
      "quadrant": "1",
      "description": "JS package that renders MathML to HTML or SVG markup. We are using v2.x, will upgrade to v3.x eventually.  We use this in a number of our frontend repos for math markup (ORA, in particular).",
      "id": "MathJax",
      "key": "MathJax",
      "title": "MathJax"
    },
    {
      "quadrant": "1",
      "description": "A cloud computing company that offers hosting and serverless backend services for web applications and static websites. Currently used for Paragon PR deploy previews.",
      "id": "Netlify",
      "key": "Netlify",
      "title": "Netlify"
    },
    {
      "quadrant": "1",
      "description": "<a href=\"https://docs.npmjs.com/about-npm\">Node Package Manager</a> is an industry standard JavaScript package manager that we use to manage all of the dependencies we use in our frontend applications and libraries.  This is a core part of our JavaScript build infrastructure for all projects.  We do not use yarn - an alternative - today.",
      "id": "npm",
      "key": "npm",
      "title": "npm"
    },
    {
      "quadrant": "1",
      "description": "A maintained set of React components built around the Javascript UI components available in the bootstrapJS library. These form the underpinning of much of the Paragon component library.",
      "id": "react-bootstrap",
      "key": "react-bootstrap",
      "title": "react-bootstrap"
    },
    {
      "quadrant": "1",
      "description": "React Hooks are pure JavaScript components written explicitly in functional React components that allow you to access React state and life cycle features from functional components and provide the option to move away from writing classes. Hooks make it easy to extract and reuse stateful logic across components.<br/><br/>\n\nThis technique is used in much of our React micro-frontend code.  We have found that functional React components with hooks work well for the vast majority of our use cases; however, particularly complex components with event handlers and state management logic sometimes benefit from being written as a class component.",
      "id": "React hooks",
      "key": "React hooks",
      "title": "React hooks"
    },
    {
      "quadrant": "1",
      "description": "React is a powerful JavaScript library for creating user interfaces, allowing you to compose complex UIs from small and isolated/re-usable pieces of code called \"components\".\nThis is the core UI framework for all MFE UI development today in the Open edX ecosystem.",
      "id": "React",
      "key": "React",
      "title": "React"
    },
    {
      "quadrant": "1",
      "description": "react-router is an industry standard React client-side routing library. It lets you write declarative 'routes' in your frontend that will be rendered without a page refresh when their path matches the path in the URL.  We use this in most of our MFEs, and have found it a very effective way of managing sub-pages within a micro-frontend.",
      "id": "react-router",
      "key": "react-router",
      "title": "react-router"
    },
    {
      "quadrant": "1",
      "description": "react-test-renderer is a testing tool that allows rendering of React components into pure JavaScript objects that can be queried and rendered into snapshots for testing.\nIn particular, this tool is more powerful for rendering hook-based React components than its counterpart (Enzyme). This tool is used to write unit tests in many of our MFEs and Paragon, and is an important tool in our testing strategy.",
      "id": "react-test-renderer",
      "key": "react-test-renderer",
      "title": "react-test-renderer"
    },
    {
      "quadrant": "1",
      "description": "Redux is a powerful state management library used in many of our micro-frontends.  We recommend using it with the redux-toolkit library, which simplifies the implementation and reduces the amount of boilerplate needed to use Redux.  Some micro-frontends choose not to use Redux; they opt for simpler state management mechanisms available in React itself, such as component state and prop passing, as well as React context.  When to use Redux is a frequent topic of debate. In many cases where a reducer pattern is useful, using Redux and redux-toolkit rather than hand-coding reducers for the `useReducer` hook can - again - reduce boilerplate and help ensure the code follows best practices and is approachable.  ",
      "id": "Redux",
      "key": "Redux",
      "title": "Redux"
    },
    {
      "quadrant": "1",
      "description": "A simple Redux middleware that helps standardize how a frontend application handles side effects and asynchronous tasks.  It enables complex data actions to be grouped and gives us a consistent, reusable, predictable place to make API calls outside the React component hierarchy itself.  redux-thunk is used widely in our micro-frontends, and has proven itself to be much more approachable than other tools like redux-saga.",
      "id": "redux-thunk",
      "key": "redux-thunk",
      "title": "redux-thunk"
    },
    {
      "quadrant": "1",
      "description": "Renovate is an automated dependency updater for GitHub repositories. Open edX repositories use Renovate to automate updates of frontend packages (the edx-requirements-bot covers Python and other backend packages).",
      "id": "Renovate",
      "key": "Renovate",
      "title": "Renovate"
    },
    {
      "quadrant": "1",
      "description": "requirejs is a JavaScript file and module loader used in some of our legacy frontends.  It is not used in micro-frontends at all; MFEs use webpack.  We should not use requirejs anymore, and should attempt to remove it in favor of webpack wherever possible.",
      "id": "requirejs",
      "key": "requirejs",
      "title": "requirejs"
    },
    {
      "quadrant": "1",
      "description": "SASS is a preprocessor scripting language that is compiled into CSS which adds features such as variables, nested rules, inline imports, and more.\nThe Open edX platform uses SASS extensively, and because of our usage of Bootstrap 4, relies on it for branding.",
      "id": "SASS",
      "key": "SASS",
      "title": "SASS"
    },
    {
      "quadrant": "1",
      "description": "<a href=\" https://www.tiny.cloud/get-tiny/downloads/\">TinyMCE</a> is a Javascript-based rich-text editor, used for allowing users to enter text with rich formatting (as well as adding certain files/images to their submisisons). Used in applications (such as Open Response Assessments) where users wish to be able to submit formatted document-style text content.  Note that we have a plugin to make it easier to mark spans with different lang attributes.",
      "id": "TinyMCE",
      "key": "TinyMCE",
      "title": "TinyMCE"
    },
    {
      "quadrant": "1",
      "description": "TypeScript is a strict syntactical superset of JavaScript, adding optional static typing to the language. TypeScript may require architectural support; however, it can be configured to allow migration on a file-by-file basis rather than converting to the new paradigm all at once. Some providers in the community are known to favor TypeScript. We recommend that component maintainers consider using TypeScript where static typing is most valuable (e.g., JS libaries, data model layer), rather than opting to refactor all existing JavaScript to TypeScript unless there is demonstrated value in doing so.",
      "id": "TypeScript",
      "key": "TypeScript",
      "title": "TypeScript"
    },
    {
      "quadrant": "1",
      "description": "Webpack is a JavaScript module bundler, capable of transforming, building, or packaging almost all front-end assets.  We use webpack extensively in all of our micro-frontends, and in some legacy frontends co-located with their corresponding backends.  Webpack is an industry standard and has proven itself to be very flexible and have a wider variety of available plugins and loaders than other bundlers like rollup or parcel.  We expect to continue to invest in our usage of webpack.",
      "id": "Webpack",
      "key": "Webpack",
      "title": "Webpack"
    },
    {
      "quadrant": "1",
      "description": "An alternative to npm for Javascript package installation. The two have minor differences in speed/performance, security, and implementation. In many of these categories, yarn is slightly ahead of npm, but npm is also keeping pace nicely. There are no current plans to adopt yarn, but it has been posed as an alternative to npm.",
      "id": "yarn",
      "key": "yarn",
      "title": "yarn"
    },
    {
      "quadrant": "2",
      "description": "<a href=\"https://github.com/openedx/blockstore\">Blockstore</a> is a learning objects repository developed for the next version of content libraries, and intended as a long term replacement for modulestore.",
      "id": "Blockstore",
      "key": "Blockstore",
      "title": "Blockstore"
    },
    {
      "quadrant": "2",
      "description": "<a href=\"https://github.com/openedx/edx-celeryutils\">celery-utils</a> is an Open edX Python module hosted in Github which contains common code across multiple Celery tasks used in Open edX to provide common features such as logging, error recovery, and Django management commands which perform common tasks such as re-running failed tasks and deleting old tasks.",
      "id": "celery-utils",
      "key": "celery-utils",
      "title": "celery-utils"
    },
    {
      "quadrant": "2",
      "description": "The development environment for Open edX services.  Now based on Blip: Docker containers, it had previously used a Vagrant virtual machine.  Work is planned in the near future to switch to using Blip: Tutor instead for this purpose.",
      "id": "devstack",
      "key": "devstack",
      "title": "devstack"
    },
    {
      "quadrant": "2",
      "description": "<a href=\"https://edx-ace.readthedocs.io/en/latest/index.html#\">The Automated Communication Engine</a>, <i>ACE</i> for short, is a Django app for messaging learners on the Open edX platform. This app can be installed in any django application, but has only been tested with edx-platform. It is intended to leverage all of the information available in the host system to personalize the communication to learners, including, but not limited to, the timing of the communication and the language of the message. It reuses existing technologies like Django templates overrides and translation automation to simplify the personalization of messages for different contexts such as different site configurations. edX.org has recently migrated much of this functionality to a third-party tool (Braze).",
      "id": "edx-ace",
      "key": "edx-ace",
      "title": "edx-ace"
    },
    {
      "quadrant": "2",
      "description": "The edx-bootstrap library is a prior iteration of our Bootstrap theme.  It was folded into more recent versions of Blip: Paragon as of ~2019, and has been deprecated.  It is still in use by some of our legacy frontends, but should be removed when upgrading Paragon to more recent versions.",
      "id": "edx-bootstrap",
      "key": "edx-bootstrap",
      "title": "edx-bootstrap"
    },
    {
      "quadrant": "2",
      "description": "Python packages which use a framework defined in the edx-django-utils package to be automatically registered with and used by the service they are installed into without needing to change multiple Django settings. This is very useful for optional Open edX features that some installations may choose not to use.  Currently only used in edx-platform, although the framework is designed to also be usable in other IDAs.",
      "id": "edX Django app plugins",
      "key": "edX Django app plugins",
      "title": "edX Django app plugins"
    },
    {
      "quadrant": "2",
      "description": "The <a href=\"https://github.com/openedx/edx-ui-toolkit\">UI Toolkit</a> is a prior iteration of a UI component library.  It has been deprecated in favor of the Paragon design system, and is only in use in some of our legacy frontends.  Micro-frontends do not use it at all.",
      "id": "edx-ui-toolkit",
      "key": "edx-ui-toolkit",
      "title": "edx-ui-toolkit"
    },
    {
      "quadrant": "2",
      "description": "<a href=\"https://github.com/openedx/frontend-build\">frontend-build</a> is a library of build tools and configurations for our micro-frontends.  It contains webpack, babel, eslint, and Jest configurations, as well as scripts used by our micro-frontends to take advantage of them.  It is our standard for all micro-frontend building. ",
      "id": "frontend-build",
      "key": "frontend-build",
      "title": "frontend-build"
    },
    {
      "quadrant": "2",
      "description": "<a href=\"https://github.com/openedx/frontend-platform\">frontend-platform</a> is an application framework used as the basis for all Open edX micro-frontends.  It provides an application initialization lifecycle, a number of foundational services (analytics, authentication, logging, i18n), and helpful React components.  ",
      "id": "frontend-platform",
      "key": "frontend-platform",
      "title": "frontend-platform"
    },
    {
      "quadrant": "2",
      "description": "<a href=\"https://github.com/openedx/edx-platform/tree/master/common/lib/xmodule/xmodule/modulestore\">Modulestore</a> is an Open edX code abstraction which is part of edx-platform. It stores and retrieves course module content to/from MongoDB and MySQL, while adding other stateful and stateless to the module. The Open edX platform has gone through three iterations of the modulestore - XML-based, \"Old Mongo\", and the current \"Split Mongo\" implementation. The modulestore is also shared by Studio and the LMS, though it is known to be non-performant. The Open edX platform is moving in the direction of using the modulestore in Studio only, while using a more performant, non-modulestore data model/interface for the LMS.\n",
      "id": "Modulestore",
      "key": "Modulestore",
      "title": "Modulestore"
    },
    {
      "quadrant": "2",
      "description": "Blip: Paragon contains a library of SVG icons for use in frontends, based on MUI icons.  We prefer the use of these icons over font-awesome or other icon libraries, and are actively investing in adding icons for all of our use cases.  We originally created this library because font-awesome didn't have some icons we needed, and have since started switching over to it for consistency and to keep our bundle sizes down.",
      "id": "Paragon icons",
      "key": "Paragon icons",
      "title": "Paragon icons"
    },
    {
      "quadrant": "2",
      "description": "<a href=\"https://github.com/openedx/paragon\">Paragon</a> is the design system and component library for Open edX frontends.  It provides a stylesheet built on Blip: Bootstrap, as well as a wide variety of Blip: React components for use in our frontends.  We're actively investing in its further development, and encourage teams to think about contributing as they create new components in our applications.",
      "id": "Paragon",
      "key": "Paragon",
      "title": "Paragon"
    },
    {
      "quadrant": "2",
      "description": "A Python package providing a framework for implementing command-line tasks using Python code.  Within Open edX it is only used by edx-platform, and the possibility of switching that to an alternative framwork is periodically considered.",
      "id": "paver",
      "key": "paver",
      "title": "paver"
    },
    {
      "quadrant": "2",
      "description": "A Blip: Docker based development and deployment environment for Open edX.  Already an officially supported deployment option, it is likely to become the official development environment also in the near future (replacing Blip: devstack).",
      "id": "Tutor",
      "key": "Tutor",
      "title": "Tutor"
    },
    {
      "quadrant": "2",
      "description": "The <a href=\"https://github.com/edx/ux-pattern-library\">UX Pattern Library</a> is a prior iteration of a UI library and frontend styleguide for Open edX applications and sites.  Its use has been deprecated in favor of the Blip: Paragon design system.  It has not seen any investment since approximately 2016 and should be removed as a dependency where possible.",
      "id": "ux-pattern-library",
      "key": "ux-pattern-library",
      "title": "ux-pattern-library"
    },
    {
      "quadrant": "2",
      "description": "Each course is built as a tree of <a href=\"https://github.com/openedx/XBlock\">XBlocks</a>. An XBlock is a specified as a component architecture and allows new courseware experiences to be implemented and plugged into edx-platform for use by all courses - and more generically by any platform that defines an XBlock runtime. Each edx-platform XBlock is implemented as a separate Github repository, which contains both server-side and browser-side code.",
      "id": "XBlock",
      "key": "XBlock",
      "title": "XBlock"
    },
    {
      "quadrant": "3",
      "description": "ADRs are local lightweight documents of technical decisions co-located with its corresponding code. They are much easier to maintain than traditional design documents since they are a running log of decisions without the need to update old decisions.</br></br>They allow developers to understand the rationale behind the code and the archeological path to its current state. These records prove to be an <a href=\"https://www.thoughtworks.com/radar/techniques/lightweight-architecture-decision-records\">invaluable technique</a> for engineering teams to onboard new members, to understand discovered historical traces, to refer back to past decisions, and to support external oversight. See <a href=\"https://github.com/openedx/open-edx-proposals/pull/74/\">OEP-19: Developer Docs</a> for more information.</br></br>See 'Blip: OEPs' as an alternative process for documenting technical decisions that have system-wide impact.",
      "id": "ADRs",
      "key": "ADRs",
      "title": "ADRs"
    },
    {
      "quadrant": "3",
      "description": "We often refer to the edx-platform monolithic repository as a \"ball of mud\", because it lacks clear boundaries and extension points.  This is not a pattern we want to continue, and much of our work is focused on cleaning up the \"ball of mud\" via the techniques in the 'Blip: B.E.E.S' blip.",
      "id": "Ball of Mud",
      "key": "Ball of Mud",
      "title": "Ball of Mud"
    },
    {
      "quadrant": "3",
      "description": "While the <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1074397222/Architecture+Manifesto+WIP\">Architecture Manifesto</a> provides long-term principles for our technical architecture, B.E.E.S. is a mnemonic acronym for the 4-pillar architecture strategy that will lead us to our vision: an extensible distibuted system that supports long-term innovative growth.\n</br></br><ol>\n<li><b>Boundaries</b> - see 'Blip: Boundaries (domain-driven)'</li>\n<li><b>Extensions</b> - see 'Blip: Extensible Cores'</li>\n<li><b>Events</b> - see 'Blip: Event-driven Architecture'</li>\n<li><b>Standards</b> - see 'Blip: Standards-based Development'</li>\n</ol>\n</br>See the <a href=\"https://docs.google.com/presentation/d/1Tm-Ha1rc8Ifj8UDMhhUiQ8Rk55zRDTZJkDcoq8lUsHc/edit\">Arch B.E.E.S. slides</a>, including speaker notes, for more information.\n</br></br>We are moving forward on all 4 simultaneously through active efforts on our <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1812037671/FY21+Architecture+User+Story+Roadmap\">architecture roadmap</a>.",
      "id": "B.E.E.S.",
      "key": "B.E.E.S.",
      "title": "B.E.E.S."
    },
    {
      "quadrant": "3",
      "description": "Defining <b>boundaries</b> is needed to achieve modularity and a decoupled system. Defined boundaries allow us to know the intended responsibilities of components and how they are intended to evolve over time. A component can be a single Python module, a Django app, a Frontend folder, a Plugin, an entire microservice or microfrontend.\n</br></br>\nNot all boundaries are created equal. There are tradeoffs. Business-minded long-term implications for cohesion and coupling need to be considered. See the slides and video from the <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1287684148/Arch+Study+Group\">2020-09-08 Arch Study workshop on Boundaries</a> for a deeper dive and exercises on this topic.\n</br></br>\nThe <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1074397222/Architecture+Manifesto+WIP#Clear-Bounded-Contexts\">Clear Bounded Contexts section of the Architecture Manifesto</a> provides additional links for what to consider when defining business-minded boundaries, including Domain-driven Design.\n</br></br>\nFinally, take a look at 'Blip: READMEs' for a technique to document a component's Single Responsibility. ",
      "id": "Boundaries (domain driven)",
      "key": "Boundaries (domain driven)",
      "title": "Boundaries (domain driven)"
    },
    {
      "quadrant": "3",
      "description": "Code coverage is used during testing to assess what portions of the code are being exercised by the tests.  It provides information to code authors about gaps in testing, and helps to provide assurance about the correct behavior of the code.\nWe don't have a specific target we are trying to hit. In some repos, we have checks that a pull request has not decreased the total coverage percentage.",
      "id": "Code coverage",
      "key": "Code coverage",
      "title": "Code coverage"
    },
    {
      "quadrant": "3",
      "description": "<a href=\"https://martinfowler.com/articles/consumerDrivenContracts.html\">Consumer-driven contracts</a> are an essential part of a mature microservice testing portfolio, enabling independent service deployments. When two independently developed services are collaborating, changes to the supplier’s API can cause failures for its consumers. Consuming services usually cannot test against live suppliers since such tests are slow and brittle. Consumer teams can protect themselves from these failures by providing their own tests to the supplier, who can then run all their consumers’ contract tests to determine if their changes are likely to cause problems.",
      "id": "Consumer-based API contract testing",
      "key": "Consumer-based API contract testing",
      "title": "Consumer-based API contract testing"
    },
    {
      "quadrant": "3",
      "description": "<a href=\"https://www.conventionalcommits.org/en/v1.0.0/\">Conventional Commits</a> is a\nset of guidelines for writing git commit messages.  Our standard for using conventional commits\nis <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/oep-0051-bp-conventional-commits.html\">OEP-51, Conventional Commits</a>.\nConventional commits guide the author to indicate the broad category of change, and its implications.\nUsing conventional commits helps readers and adopters of the code to understand how it is changing.\nConventional commits are not currently required, but are <i>strongly</i> encouraged.",
      "id": "Conventional Commits",
      "key": "Conventional Commits",
      "title": "Conventional Commits"
    },
    {
      "quadrant": "3",
      "description": "CSS-in-JS is a technique - <strong>not currently used by Open edX</strong> - in which styles are embedded into JavaScript-based UI components, rather than being coded into a CSS file.  It is an attractive option in that it promotes modularity by co-locating styling information with the component that needs it, similar to how JSX started co-locating markup with the JavaScript that manipulates it. The decision to use  CSS-in-JS techniques/libraries in the future is complicated by the need to keep our system themeable, and also our hesitancy to replace our Bootstrap-based styling with a completely different system.  Such a change could not possibly happen all at once, in which case we would exist with two separate styling systems for some period of time, which would be pretty problematic.",
      "id": "CSS-in-JS",
      "key": "CSS-in-JS",
      "title": "CSS-in-JS"
    },
    {
      "quadrant": "3",
      "description": "<i>Remove dead code wherever possible. It gets in the way and slows you down.</i> </br></br> <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/oep-0021-proc-deprecation.html\">OEP-0021: Deprecation and Removal</a> defines a clear and agreed upon process for removing legacy code, which we strongly encourage everyone to follow and put into regular practice as part of the normal development lifecyle.",
      "id": "DEPR",
      "key": "DEPR",
      "title": "DEPR"
    },
    {
      "quadrant": "3",
      "description": "Whenver possible documentation should be localized to the thing it is describing.  This helps both with discovery of the documentation by readers but also helps ease the burden of documentation maintenance since writers can update the documentation alongside the code that it describes.  See <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/oep-0019-bp-developer-documentation.html\">OEP-19</a> for more details.",
      "id": "Docs right in the repo",
      "key": "Docs right in the repo",
      "title": "Docs right in the repo"
    },
    {
      "quadrant": "3",
      "description": "The Open edX platform will be implementing more and more best practices of an Event-Driven Architecture. See <a href=\"https://github.com/openedx/open-edx-proposals/blob/master/oeps/architectural-decisions/oep-0041-arch-async-server-event-messaging.rst\">OEP-41: Asynchronous Server Event Message Format</a> for more details, including a discussion of benefits such as: eliminating blocking, synchronous requests, eliminating expensive batch synchronization, reducing the need for plugins, and simplifying integration to external systems. It is likely that a new Event Bus technology will soon be added to the radar.",
      "id": "Event-driven Architecture",
      "key": "Event-driven Architecture",
      "title": "Event-driven Architecture"
    },
    {
      "quadrant": "3",
      "description": "Experiments are intentionally developed very quickly with fewer quality controls since it as assumed that most will be unsuccessful and will later be removed. It is common that some courses will want to \"opt-out\" of particular experiments. The <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1250623700/Bucketing+users+for+an+experiment\">ExperimentWaffleFlag</a> provides a fast kill-switch for experiments as well as standardizing a process for excluding courses from experiments that would otherwise have been included. These tools enable re-use of experiment-related analytical tools since they standardize the data emitted by the experiment. Lastly, these tools make it simple to keep track of all experiments that have not yet been rolled out or removed by simply searching for usages of this type of feature flag.",
      "id": "Experimenting and A/B testing with django waffle experiment flag",
      "key": "Experimenting and A/B testing with django waffle experiment flag",
      "title": "Experimenting and A/B testing with django waffle experiment flag"
    },
    {
      "quadrant": "3",
      "description": "To allow Open edX to solve different problems for different people in the community, having the core software be extensible is essential. Because we have adopted a micro services architecture (See 'Blip:Micro-services'), there is no single core but rather a series of core systems that should each provide extension points to allow for experimentation and innovation at a faster development speed than if all features had to be directly merged into the core systems.",
      "id": "Extensible cores",
      "key": "Extensible cores",
      "title": "Extensible cores"
    },
    {
      "quadrant": "3",
      "description": "Using a local commit hook to run a tool (such as black) to automatically reformat source code before the commit completes, which saves time vs having a CI check that tells a developer that there's a problem with their formatting and they need to go run the tool themselves and make a new commit.  Some individual Open edX developers may be doing this, but it hasn't yet been adopted as a standard practice.",
      "id": "Lint / Auto reformat on commit",
      "key": "Lint / Auto reformat on commit",
      "title": "Lint / Auto reformat on commit"
    },
    {
      "quadrant": "3",
      "description": "Micro-frontends (MFEs) are an approach to developing frontend applications where the site is broken up into domain-specific modules which are then independently deployed and maintained in separate repositories.  This helps establish strong boundaries around these domains and ensures they remain loosely coupled.  The approach is the frontend version of a micro-service architecture.  In the Open edX platform, micro-frontends are purely frontend and contain no backend code.  MFEs communicate with backend services via RESTful APIs (generally), and share some foundational libraries like frontend-build, frontend-platform, and paragon.  A downside of this approach is that each MFE bundles its own third-party dependencies, so there is some code duplication and redundant assets as a user navigates around the site from MFE to MFE.  We've found the micro-frontend approach to have a very positive effect on developer velocity and our ability to continuously deploy our frontends.  We are in the process of replatforming all \"legacy\" frontends to be micro-frontends.",
      "id": "Micro-frontends",
      "key": "Micro-frontends",
      "title": "Micro-frontends"
    },
    {
      "quadrant": "3",
      "description": "Using a collection of business and organization aligned smaller services, each dedicated to a specific functionality domain, rather than one monolithic service for an entire site.  Open edX started as a monolithic service but has started implementing more and more functionality in new micro-services to accelerate development and improve maintainability as the platform grows. When defining micro-services, ensure services are not <i>too</i> small, which can lead to a 'distributed monolith'. See `Blip: Boundaries (domain driven)`.",
      "id": "Micro-services",
      "key": "Micro-services",
      "title": "Micro-services"
    },
    {
      "quadrant": "3",
      "description": "Module federation is a technique allowing us to share JavaScript modules across independently deployed micro-frontends.  While we are not using it today, we believe it can help us firm up our domain boundaries, allow teams to work more independently, and reduce bundle sizes by sharing common modules used by multiple MFEs.  It comes with some complexity around versioning of shared dependencies, however, which has prevented us from moving forward with adoption.  Because it has no ability to establish a security sandbox around code loaded from outside our trust domain, it has limited utility for extensibility.  Supporting module federation in MFEs is not currently scheduled on our roadmap.",
      "id": "Module federation",
      "key": "Module federation",
      "title": "Module federation"
    },
    {
      "quadrant": "3",
      "description": "OEPs (Open edX Proposals) are a collection of system-wide technology decisions accepted by the Open edX community. They come in the form of best practices, architecture designs, or processes. Inspired by <a href=\"https://www.python.org/dev/peps/pep-0001/\">Python Enhancement Proposals (PEPs)</a>, each OEP provides its use cases and rationales. OEPs are described in <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/oep-0001.html\">OEP-1</a> and published in the <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/index.html\">OEP Index on Read the Docs</a>.</br></br>See 'Blip: ADRs' as an alternative to OEPs for a lighter weight process to document localized technical decisions.",
      "id": "OEPs",
      "key": "OEPs",
      "title": "OEPs"
    },
    {
      "quadrant": "3",
      "description": "PR deploy previews are a way of improving our CI/CD pipeline by allowing us to share and see our code running in an environment prior to merge into main.  We primarily use this in Blip: Paragon today, but its a technique we'd like to expand to micro-frontends in general.  On each commit of a component library or micro-frontend, we would build and deploy a preview of the changes made in the commit / PR, and keep this deploy preview up-to-date on successive commits within the same PR. ",
      "id": "PR deploy previews",
      "key": "PR deploy previews",
      "title": "PR deploy previews"
    },
    {
      "quadrant": "3",
      "description": "Server-side templates are a technique used to render HTML on the server and then serve it to the client as part of the initial page load.  In our ecosystem, it is most commonly done via Django templates in our \"legacy\" frontend systems, although the intention is to replatform these.  It is not done in any micro-frontends, in favor of using React and client-side rendering to generate as much of the page as possible.<br/><br/>We're moving away from using server side templates as part of the micro-frontend replatforming.  They tightly couple frontend rendering to backend code and DB queries, and when not used mindfully, blur API boundaries of both the frontend and backend, reducing the overall extensibility of the platform. Server side templates continue to be used for Django admin pages, and there is no intention of changing that.",
      "id": "Server side templates",
      "key": "Server side templates",
      "title": "Server side templates"
    },
    {
      "quadrant": "3",
      "description": "An in-process publish/subscribe framework built into Django.  Basically a lighteight eventing system useful when the event handlers are local and finish quickly.  Open edX uses these extensively in many of its services and packages.",
      "id": "Synchronous signal handling (Django signals)",
      "key": "Synchronous signal handling (Django signals)",
      "title": "Synchronous signal handling (Django signals)"
    },
    {
      "quadrant": "3",
      "description": "The Tech Radar is a living document that records our technology decisions as they change over time, evaluating their level of adoption and suitability to the Open edX platform’s needs. More information can be found <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/2844786770/Open+edX+Technology+Radar\">here</a>.",
      "id": "Tech Radar",
      "key": "Tech Radar",
      "title": "Tech Radar"
    },
    {
      "quadrant": "3",
      "description": "Optional metadata for the types of Python function arguments and return values, which can be used to gain many of the benefits of static type checking.  We're currently only using this in 3 Open edX repositories, but would like to start using it more extensively.  Here is the relevant <a href=\"https://github.com/search?q=mypy+repo%3Aedx%2Fblockstore+repo%3Aedx%2Fedx-platform+repo%3Aedx%2Fopenedx-webhooks&type=Code&ref=advsearch&l=&l=\">mypy configuration and usage</a>.",
      "id": "Type annotations",
      "key": "Type annotations",
      "title": "Type annotations"
    },
    {
      "quadrant": "4",
      "description": "ADRs are local lightweight documents of technical decisions co-located with its corresponding code. They are much easier to maintain than traditional design documents since they are a running log of decisions without the need to update old decisions.</br></br>They allow developers to understand the rationale behind the code and the archeological path to its current state. These records prove to be an <a href=\"https://www.thoughtworks.com/radar/techniques/lightweight-architecture-decision-records\">invaluable technique</a> for engineering teams to onboard new members, to understand discovered historical traces, to refer back to past decisions, and to support external oversight. See <a href=\"https://github.com/openedx/open-edx-proposals/pull/74/\">OEP-19: Developer Docs</a> for more information.</br></br>See 'Blip: OEPs' as an alternative process for documenting technical decisions that have system-wide impact.",
      "id": "ADRs",
      "key": "ADRs",
      "title": "ADRs"
    },
    {
      "quadrant": "4",
      "description": "We often refer to the edx-platform monolithic repository as a \"ball of mud\", because it lacks clear boundaries and extension points.  This is not a pattern we want to continue, and much of our work is focused on cleaning up the \"ball of mud\" via the techniques in the 'Blip: B.E.E.S' blip.",
      "id": "Ball of Mud",
      "key": "Ball of Mud",
      "title": "Ball of Mud"
    },
    {
      "quadrant": "4",
      "description": "While the <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1074397222/Architecture+Manifesto+WIP\">Architecture Manifesto</a> provides long-term principles for our technical architecture, B.E.E.S. is a mnemonic acronym for the 4-pillar architecture strategy that will lead us to our vision: an extensible distibuted system that supports long-term innovative growth.\n</br></br><ol>\n<li><b>Boundaries</b> - see 'Blip: Boundaries (domain-driven)'</li>\n<li><b>Extensions</b> - see 'Blip: Extensible Cores'</li>\n<li><b>Events</b> - see 'Blip: Event-driven Architecture'</li>\n<li><b>Standards</b> - see 'Blip: Standards-based Development'</li>\n</ol>\n</br>See the <a href=\"https://docs.google.com/presentation/d/1Tm-Ha1rc8Ifj8UDMhhUiQ8Rk55zRDTZJkDcoq8lUsHc/edit\">Arch B.E.E.S. slides</a>, including speaker notes, for more information.\n</br></br>We are moving forward on all 4 simultaneously through active efforts on our <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1812037671/FY21+Architecture+User+Story+Roadmap\">architecture roadmap</a>.",
      "id": "B.E.E.S.",
      "key": "B.E.E.S.",
      "title": "B.E.E.S."
    },
    {
      "quadrant": "4",
      "description": "Defining <b>boundaries</b> is needed to achieve modularity and a decoupled system. Defined boundaries allow us to know the intended responsibilities of components and how they are intended to evolve over time. A component can be a single Python module, a Django app, a Frontend folder, a Plugin, an entire microservice or microfrontend.\n</br></br>\nNot all boundaries are created equal. There are tradeoffs. Business-minded long-term implications for cohesion and coupling need to be considered. See the slides and video from the <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1287684148/Arch+Study+Group\">2020-09-08 Arch Study workshop on Boundaries</a> for a deeper dive and exercises on this topic.\n</br></br>\nThe <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1074397222/Architecture+Manifesto+WIP#Clear-Bounded-Contexts\">Clear Bounded Contexts section of the Architecture Manifesto</a> provides additional links for what to consider when defining business-minded boundaries, including Domain-driven Design.\n</br></br>\nFinally, take a look at 'Blip: READMEs' for a technique to document a component's Single Responsibility. ",
      "id": "Boundaries (domain driven)",
      "key": "Boundaries (domain driven)",
      "title": "Boundaries (domain driven)"
    },
    {
      "quadrant": "4",
      "description": "Code coverage is used during testing to assess what portions of the code are being exercised by the tests.  It provides information to code authors about gaps in testing, and helps to provide assurance about the correct behavior of the code.\nWe don't have a specific target we are trying to hit. In some repos, we have checks that a pull request has not decreased the total coverage percentage.",
      "id": "Code coverage",
      "key": "Code coverage",
      "title": "Code coverage"
    },
    {
      "quadrant": "4",
      "description": "<a href=\"https://martinfowler.com/articles/consumerDrivenContracts.html\">Consumer-driven contracts</a> are an essential part of a mature microservice testing portfolio, enabling independent service deployments. When two independently developed services are collaborating, changes to the supplier’s API can cause failures for its consumers. Consuming services usually cannot test against live suppliers since such tests are slow and brittle. Consumer teams can protect themselves from these failures by providing their own tests to the supplier, who can then run all their consumers’ contract tests to determine if their changes are likely to cause problems.",
      "id": "Consumer-based API contract testing",
      "key": "Consumer-based API contract testing",
      "title": "Consumer-based API contract testing"
    },
    {
      "quadrant": "4",
      "description": "<a href=\"https://www.conventionalcommits.org/en/v1.0.0/\">Conventional Commits</a> is a\nset of guidelines for writing git commit messages.  Our standard for using conventional commits\nis <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/oep-0051-bp-conventional-commits.html\">OEP-51, Conventional Commits</a>.\nConventional commits guide the author to indicate the broad category of change, and its implications.\nUsing conventional commits helps readers and adopters of the code to understand how it is changing.\nConventional commits are not currently required, but are <i>strongly</i> encouraged.",
      "id": "Conventional Commits",
      "key": "Conventional Commits",
      "title": "Conventional Commits"
    },
    {
      "quadrant": "4",
      "description": "CSS-in-JS is a technique - <strong>not currently used by Open edX</strong> - in which styles are embedded into JavaScript-based UI components, rather than being coded into a CSS file.  It is an attractive option in that it promotes modularity by co-locating styling information with the component that needs it, similar to how JSX started co-locating markup with the JavaScript that manipulates it. The decision to use  CSS-in-JS techniques/libraries in the future is complicated by the need to keep our system themeable, and also our hesitancy to replace our Bootstrap-based styling with a completely different system.  Such a change could not possibly happen all at once, in which case we would exist with two separate styling systems for some period of time, which would be pretty problematic.",
      "id": "CSS-in-JS",
      "key": "CSS-in-JS",
      "title": "CSS-in-JS"
    },
    {
      "quadrant": "4",
      "description": "<i>Remove dead code wherever possible. It gets in the way and slows you down.</i> </br></br> <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/oep-0021-proc-deprecation.html\">OEP-0021: Deprecation and Removal</a> defines a clear and agreed upon process for removing legacy code, which we strongly encourage everyone to follow and put into regular practice as part of the normal development lifecyle.",
      "id": "DEPR",
      "key": "DEPR",
      "title": "DEPR"
    },
    {
      "quadrant": "4",
      "description": "Whenver possible documentation should be localized to the thing it is describing.  This helps both with discovery of the documentation by readers but also helps ease the burden of documentation maintenance since writers can update the documentation alongside the code that it describes.  See <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/oep-0019-bp-developer-documentation.html\">OEP-19</a> for more details.",
      "id": "Docs right in the repo",
      "key": "Docs right in the repo",
      "title": "Docs right in the repo"
    },
    {
      "quadrant": "4",
      "description": "The Open edX platform will be implementing more and more best practices of an Event-Driven Architecture. See <a href=\"https://github.com/openedx/open-edx-proposals/blob/master/oeps/architectural-decisions/oep-0041-arch-async-server-event-messaging.rst\">OEP-41: Asynchronous Server Event Message Format</a> for more details, including a discussion of benefits such as: eliminating blocking, synchronous requests, eliminating expensive batch synchronization, reducing the need for plugins, and simplifying integration to external systems. It is likely that a new Event Bus technology will soon be added to the radar.",
      "id": "Event-driven Architecture",
      "key": "Event-driven Architecture",
      "title": "Event-driven Architecture"
    },
    {
      "quadrant": "4",
      "description": "Experiments are intentionally developed very quickly with fewer quality controls since it as assumed that most will be unsuccessful and will later be removed. It is common that some courses will want to \"opt-out\" of particular experiments. The <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/1250623700/Bucketing+users+for+an+experiment\">ExperimentWaffleFlag</a> provides a fast kill-switch for experiments as well as standardizing a process for excluding courses from experiments that would otherwise have been included. These tools enable re-use of experiment-related analytical tools since they standardize the data emitted by the experiment. Lastly, these tools make it simple to keep track of all experiments that have not yet been rolled out or removed by simply searching for usages of this type of feature flag.",
      "id": "Experimenting and A/B testing with django waffle experiment flag",
      "key": "Experimenting and A/B testing with django waffle experiment flag",
      "title": "Experimenting and A/B testing with django waffle experiment flag"
    },
    {
      "quadrant": "4",
      "description": "To allow Open edX to solve different problems for different people in the community, having the core software be extensible is essential. Because we have adopted a micro services architecture (See 'Blip:Micro-services'), there is no single core but rather a series of core systems that should each provide extension points to allow for experimentation and innovation at a faster development speed than if all features had to be directly merged into the core systems.",
      "id": "Extensible cores",
      "key": "Extensible cores",
      "title": "Extensible cores"
    },
    {
      "quadrant": "4",
      "description": "Using a local commit hook to run a tool (such as black) to automatically reformat source code before the commit completes, which saves time vs having a CI check that tells a developer that there's a problem with their formatting and they need to go run the tool themselves and make a new commit.  Some individual Open edX developers may be doing this, but it hasn't yet been adopted as a standard practice.",
      "id": "Lint / Auto reformat on commit",
      "key": "Lint / Auto reformat on commit",
      "title": "Lint / Auto reformat on commit"
    },
    {
      "quadrant": "4",
      "description": "Micro-frontends (MFEs) are an approach to developing frontend applications where the site is broken up into domain-specific modules which are then independently deployed and maintained in separate repositories.  This helps establish strong boundaries around these domains and ensures they remain loosely coupled.  The approach is the frontend version of a micro-service architecture.  In the Open edX platform, micro-frontends are purely frontend and contain no backend code.  MFEs communicate with backend services via RESTful APIs (generally), and share some foundational libraries like frontend-build, frontend-platform, and paragon.  A downside of this approach is that each MFE bundles its own third-party dependencies, so there is some code duplication and redundant assets as a user navigates around the site from MFE to MFE.  We've found the micro-frontend approach to have a very positive effect on developer velocity and our ability to continuously deploy our frontends.  We are in the process of replatforming all \"legacy\" frontends to be micro-frontends.",
      "id": "Micro-frontends",
      "key": "Micro-frontends",
      "title": "Micro-frontends"
    },
    {
      "quadrant": "4",
      "description": "Using a collection of business and organization aligned smaller services, each dedicated to a specific functionality domain, rather than one monolithic service for an entire site.  Open edX started as a monolithic service but has started implementing more and more functionality in new micro-services to accelerate development and improve maintainability as the platform grows. When defining micro-services, ensure services are not <i>too</i> small, which can lead to a 'distributed monolith'. See `Blip: Boundaries (domain driven)`.",
      "id": "Micro-services",
      "key": "Micro-services",
      "title": "Micro-services"
    },
    {
      "quadrant": "4",
      "description": "Module federation is a technique allowing us to share JavaScript modules across independently deployed micro-frontends.  While we are not using it today, we believe it can help us firm up our domain boundaries, allow teams to work more independently, and reduce bundle sizes by sharing common modules used by multiple MFEs.  It comes with some complexity around versioning of shared dependencies, however, which has prevented us from moving forward with adoption.  Because it has no ability to establish a security sandbox around code loaded from outside our trust domain, it has limited utility for extensibility.  Supporting module federation in MFEs is not currently scheduled on our roadmap.",
      "id": "Module federation",
      "key": "Module federation",
      "title": "Module federation"
    },
    {
      "quadrant": "4",
      "description": "OEPs (Open edX Proposals) are a collection of system-wide technology decisions accepted by the Open edX community. They come in the form of best practices, architecture designs, or processes. Inspired by <a href=\"https://www.python.org/dev/peps/pep-0001/\">Python Enhancement Proposals (PEPs)</a>, each OEP provides its use cases and rationales. OEPs are described in <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/oep-0001.html\">OEP-1</a> and published in the <a href=\"https://open-edx-proposals.readthedocs.io/en/latest/index.html\">OEP Index on Read the Docs</a>.</br></br>See 'Blip: ADRs' as an alternative to OEPs for a lighter weight process to document localized technical decisions.",
      "id": "OEPs",
      "key": "OEPs",
      "title": "OEPs"
    },
    {
      "quadrant": "4",
      "description": "PR deploy previews are a way of improving our CI/CD pipeline by allowing us to share and see our code running in an environment prior to merge into main.  We primarily use this in Blip: Paragon today, but its a technique we'd like to expand to micro-frontends in general.  On each commit of a component library or micro-frontend, we would build and deploy a preview of the changes made in the commit / PR, and keep this deploy preview up-to-date on successive commits within the same PR. ",
      "id": "PR deploy previews",
      "key": "PR deploy previews",
      "title": "PR deploy previews"
    },
    {
      "quadrant": "4",
      "description": "Server-side templates are a technique used to render HTML on the server and then serve it to the client as part of the initial page load.  In our ecosystem, it is most commonly done via Django templates in our \"legacy\" frontend systems, although the intention is to replatform these.  It is not done in any micro-frontends, in favor of using React and client-side rendering to generate as much of the page as possible.<br/><br/>We're moving away from using server side templates as part of the micro-frontend replatforming.  They tightly couple frontend rendering to backend code and DB queries, and when not used mindfully, blur API boundaries of both the frontend and backend, reducing the overall extensibility of the platform. Server side templates continue to be used for Django admin pages, and there is no intention of changing that.",
      "id": "Server side templates",
      "key": "Server side templates",
      "title": "Server side templates"
    },
    {
      "quadrant": "4",
      "description": "An in-process publish/subscribe framework built into Django.  Basically a lighteight eventing system useful when the event handlers are local and finish quickly.  Open edX uses these extensively in many of its services and packages.",
      "id": "Synchronous signal handling (Django signals)",
      "key": "Synchronous signal handling (Django signals)",
      "title": "Synchronous signal handling (Django signals)"
    },
    {
      "quadrant": "4",
      "description": "The Tech Radar is a living document that records our technology decisions as they change over time, evaluating their level of adoption and suitability to the Open edX platform’s needs. More information can be found <a href=\"https://openedx.atlassian.net/wiki/spaces/AC/pages/2844786770/Open+edX+Technology+Radar\">here</a>.",
      "id": "Tech Radar",
      "key": "Tech Radar",
      "title": "Tech Radar"
    },
    {
      "quadrant": "4",
      "description": "Optional metadata for the types of Python function arguments and return values, which can be used to gain many of the benefits of static type checking.  We're currently only using this in 3 Open edX repositories, but would like to start using it more extensively.  Here is the relevant <a href=\"https://github.com/search?q=mypy+repo%3Aedx%2Fblockstore+repo%3Aedx%2Fedx-platform+repo%3Aedx%2Fopenedx-webhooks&type=Code&ref=advsearch&l=&l=\">mypy configuration and usage</a>.",
      "id": "Type annotations",
      "key": "Type annotations",
      "title": "Type annotations"
    }
  ]
}
